from fastapi import FastAPI, HTTPException, status
from pydantic import BaseModel, Field
from typing import Optional, List
from datetime import datetime, date
import motor.motor_asyncio
import os
from bson import ObjectId

# Initialize FastAPI app
app = FastAPI(title="Employee Management System", version="1.0.0")

# MongoDB connection
MONGO_URL = os.getenv("MONGO_URL", "mongodb://localhost:27017")
client = motor.motor_asyncio.AsyncIOMotorClient(MONGO_URL)
database = client.employee_management
employees_collection = database.employees

# Pydantic Models
class PyObjectId(ObjectId):
    @classmethod
    def __get_validators__(cls):
        yield cls.validate

    @classmethod
    def validate(cls, v):
        if not ObjectId.is_valid(v):
            raise ValueError("Invalid objectid")
        return ObjectId(v)

    @classmethod
    def __modify_schema__(cls, field_schema):
        field_schema.update(type="string")

class EmployeeBase(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    email: str = Field(..., min_length=5, max_length=100)
    phone: str = Field(..., min_length=10, max_length=15)
    department: str = Field(..., min_length=1, max_length=50)
    position: str = Field(..., min_length=1, max_length=50)
    salary: float = Field(..., gt=0)
    hire_date: date
    is_active: bool = Field(default=True)

class EmployeeCreate(EmployeeBase):
    pass

class EmployeeUpdate(BaseModel):
    name: Optional[str] = Field(None, min_length=1, max_length=100)
    email: Optional[str] = Field(None, min_length=5, max_length=100)
    phone: Optional[str] = Field(None, min_length=10, max_length=15)
    department: Optional[str] = Field(None, min_length=1, max_length=50)
    position: Optional[str] = Field(None, min_length=1, max_length=50)
    salary: Optional[float] = Field(None, gt=0)
    hire_date: Optional[date] = None
    is_active: Optional[bool] = None
    
    @validator('email')
    def validate_email(cls, v):
        if v and '@' not in v:
            raise ValueError('Invalid email format')
        return v

class Employee(EmployeeBase):
    id: PyObjectId = Field(default_factory=PyObjectId, alias="_id")
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

    class Config:
        allow_population_by_field_name = True
        arbitrary_types_allowed = True
        json_encoders = {ObjectId: str}

# Employee CRUD Endpoints
@app.post("/employees", response_model=Employee, status_code=status.HTTP_201_CREATED)
async def create_employee(employee: EmployeeCreate):
    # Check if employee with same email already exists
    existing_employee = await employees_collection.find_one({"email": employee.email})
    if existing_employee:
        raise HTTPException(status_code=400, detail="Employee with this email already exists")
    
    # Create employee document
    employee_doc = employee.dict()
    employee_doc["created_at"] = datetime.utcnow()
    employee_doc["updated_at"] = datetime.utcnow()
    
    result = await employees_collection.insert_one(employee_doc)
    created_employee = await employees_collection.find_one({"_id": result.inserted_id})
    return Employee(**created_employee)

@app.get("/employees", response_model=List[Employee])
async def get_employees(
    skip: int = 0, 
    limit: int = 10, 
    department: Optional[str] = None,
    is_active: Optional[bool] = None
):
    # Build query filter
    query = {}
    if department:
        query["department"] = {"$regex": department, "$options": "i"}
    if is_active is not None:
        query["is_active"] = is_active
    
    # Get employees with pagination
    cursor = employees_collection.find(query).skip(skip).limit(limit)
    employees = await cursor.to_list(length=limit)
    return [Employee(**employee) for employee in employees]

@app.get("/employees/{employee_id}", response_model=Employee)
async def get_employee(employee_id: str):
    if not ObjectId.is_valid(employee_id):
        raise HTTPException(status_code=400, detail="Invalid employee ID")
    
    employee = await employees_collection.find_one({"_id": ObjectId(employee_id)})
    if not employee:
        raise HTTPException(status_code=404, detail="Employee not found")
    
    return Employee(**employee)

@app.put("/employees/{employee_id}", response_model=Employee)
async def update_employee(employee_id: str, employee_update: EmployeeUpdate):
    if not ObjectId.is_valid(employee_id):
        raise HTTPException(status_code=400, detail="Invalid employee ID")
    
    # Check if employee exists
    existing_employee = await employees_collection.find_one({"_id": ObjectId(employee_id)})
    if not existing_employee:
        raise HTTPException(status_code=404, detail="Employee not found")
    
    # Prepare update data
    update_data = {k: v for k, v in employee_update.dict(exclude_unset=True).items() if v is not None}
    
    if not update_data:
        raise HTTPException(status_code=400, detail="No valid fields to update")
    
    # Check for email uniqueness if email is being updated
    if "email" in update_data:
        email_check = await employees_collection.find_one({
            "email": update_data["email"], 
            "_id": {"$ne": ObjectId(employee_id)}
        })
        if email_check:
            raise HTTPException(status_code=400, detail="Email already exists for another employee")
    
    update_data["updated_at"] = datetime.utcnow()
    
    # Update employee
    await employees_collection.update_one(
        {"_id": ObjectId(employee_id)}, 
        {"$set": update_data}
    )
    
    updated_employee = await employees_collection.find_one({"_id": ObjectId(employee_id)})
    return Employee(**updated_employee)

@app.delete("/employees/{employee_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_employee(employee_id: str):
    if not ObjectId.is_valid(employee_id):
        raise HTTPException(status_code=400, detail="Invalid employee ID")
    
    result = await employees_collection.delete_one({"_id": ObjectId(employee_id)})
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Employee not found")
    
    return None

# Search Endpoints
@app.get("/employees/search/{query}", response_model=List[Employee])
async def search_employees(query: str):
    search_filter = {
        "$or": [
            {"name": {"$regex": query, "$options": "i"}},
            {"email": {"$regex": query, "$options": "i"}},
            {"department": {"$regex": query, "$options": "i"}},
            {"position": {"$regex": query, "$options": "i"}}
        ]
    }
    
    cursor = employees_collection.find(search_filter)
    employees = await cursor.to_list(length=50)  # Limit search results
    return [Employee(**employee) for employee in employees]

@app.get("/statistics", response_model=dict)
async def get_statistics():
    total_employees = await employees_collection.count_documents({})
    active_employees = await employees_collection.count_documents({"is_active": True})
    
    # Department statistics
    department_stats = await employees_collection.aggregate([
        {"$match": {"is_active": True}},
        {"$group": {"_id": "$department", "count": {"$sum": 1}}},
        {"$sort": {"count": -1}}
    ]).to_list(length=None)
    
    return {
        "total_employees": total_employees,
        "active_employees": active_employees,
        "inactive_employees": total_employees - active_employees,
        "department_breakdown": department_stats
    }

# Health Check
@app.get("/health")
async def health_check():
    return {"status": "healthy", "message": "Employee Management System is running"}

# Root endpoint
@app.get("/")
async def root():
    return {"message": "Welcome to Employee Management System API"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)